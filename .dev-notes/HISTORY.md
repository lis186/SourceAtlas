# SourceAtlas 完整歷史記錄

**最後更新**: 2025-11-22

本檔案包含從主文檔中移除的所有歷史資訊。這些內容對於理解專案演進過程很重要，但對於快速探索和開發不是必需的。

---

## 目錄

1. [架構演進](#架構演進)
2. [格式決策歷史](#格式決策歷史)
3. [版本演進關係](#版本演進關係)
4. [完整更新日誌](#完整更新日誌)
5. [v1.0 關鍵學習（詳細版）](#v10-關鍵學習詳細版)

---

## 架構演進

### 與原始 PRD (CLI 設計) 的對比

從獨立 CLI 工具轉向 Claude Code Commands 的決策對比：

| 組件 | 原始 PRD (CLI) | 當前設計 (Commands) | 理由 |
|------|---------------|------------------|------|
| **Parser Layer** | ✅ 需實作 | ❌ 移除 | AI 自己理解代碼 |
| **Index Layer** | ✅ 需實作 | ❌ 移除 | 即時探索，不需索引 |
| **Storage Layer** | ✅ 需實作 | ❌ 移除 | 不儲存索引 |
| **Query Layer** | ✅ 需實作 | ❌ 移除 | AI 動態查詢 |
| **Command Prompts** | ❌ 無 | ✅ 新增 | 用戶明確觸發的分析流程 |
| **Helper Scripts** | ❌ 無 | ✅ 新增 | 資料收集 |

### 為什麼從 CLI 轉向 Commands

**原始 CLI 設計的問題**：
- 需要匯出索引（開發者需要離開 Claude Code）
- 預先建立索引（無法應對動態變化）
- 重複造輪子（Claude Code 已有檔案操作工具）
- 開發週期長（8 週才能完成 MVP）
- 學習成本高（需要記憶新的 CLI 命令）

**Commands 架構的優勢**：
- 原生整合在 Claude Code 中直接使用 `/atlas`
- 即時分析，按需探索，不需預先索引
- 零學習成本，自然語言互動
- 快速開發（1-2 週完成核心功能）
- AI 驅動，利用 Claude 的理解能力

---

## 格式決策歷史

### TOON 格式（已評估但未採用）

**設計理念**：通過緊湊語法減少 tokens

**範例語法**：

```toon
metadata:
  project_name: EcommerceAPI
  scan_time: 2025-11-22T10:00:00Z

## 專案指紋
project_type: WEB_APP
framework: Rails 7.0

## 假設
architecture:
  - "使用 Service Object 模式" (0.9)
    evidence: "app/services/ 有 15 個 Service"
    validate: "檢查 Service 結構"
```

**實測結果**：
- TOON: 807 tokens
- YAML: 938 tokens
- **差異**: 131 tokens (14% 節省)

**為何未採用**：
1. **14% 節省屬於邊際效益** - 非預期的 30-50%
2. **內容佔 85%，結構僅 15%** - 優化結構的效益有限
3. **生態系統價值高** - YAML 有完整工具鏈、IDE 支援、廣泛使用
4. **符合"極簡"哲學** - 使用標準工具，不重新發明輪子

**詳細分析**：見 `.dev-notes/toon-vs-yaml-analysis.md`

---

## 版本演進關係

### v2.0 成果（已完成）

```
✅ PROMPTS.md - 完整的三階段 Prompt
✅ USAGE_GUIDE.md - 使用指南
✅ README.md - 專案總覽
✅ 4 個專案驗證
✅ AI 協作識別方法
✅ 格式決策（YAML 選定）
```

### v2.5 如何使用 v2.0

```yaml
保留:
  - 三階段分析方法論
  - YAML 格式規範（v1.0 決策）
  - 高熵檔案優先策略
  - AI 協作識別邏輯
  - 驗證結果和洞察

轉換:
  - 手動 Prompt → Command 自動化
  - 複製貼上 → 斜線命令觸發
  - 獨立報告 → 對話式互動
  - TOON 評估 → YAML 採用

新增:
  - /atlas find 智慧搜尋
  - /atlas pattern 模式識別
  - /atlas explain 深入解釋
  - 輔助 Scripts
```

### 版本演進時間線

```
v1.0.0 (2025-01-15)
  ↓ 原始 PRD
  ↓ - 獨立 CLI 工具設計
  ↓ - 完整索引系統架構
  ↓ - TOON 格式提出
  ↓
v2.0.0 (2025-11-19) ⭐ 方法論驗證
  ↓ - 完成手動 Prompts 方法論
  ↓ - 驗證 5 個真實專案
  ↓ - YAML vs TOON 格式決策
  ↓ - 規模感知算法
  ↓ - 發現 AI 協作識別方法
  ↓
v2.5.0 (2025-11-20) 架構轉變
  ↓ - 從獨立 CLI 工具轉為 Claude Code 整合
  ↓ - 移除複雜的索引系統
  ↓ - 新增輔助 Scripts 架構
  ↓ - 保留 v2.0 的核心方法論
  ↓
v2.5.1 (2025-11-20) 架構最終定案
  ↓ - 確定採用 Commands 而非 Skills
  ↓ - .claude/skills/ → .claude/commands/
  ↓ - 明確優先級：/atlas-pattern 最優先
  ↓
v2.5.2 (2025-11-22) ⭐ 當前版本
    - 新增 /atlas-overview 命令
    - 專案概覽（Stage 0 指紋分析）
    - 填補 PRD 遺漏的快速理解能力
```

---

## 完整更新日誌

### v2.5.2 (2025-11-22) - 當前版本 ⭐

**重要新增**：
- **新增 `/atlas-overview` 命令** - 專案概覽（Stage 0 指紋分析）
- 填補 PRD 遺漏：提供獨立的快速理解能力
- 不需執行完整三階段，10-15 分鐘即可獲得 70-80% 理解

**實作內容**：
- `.claude/commands/atlas-overview.md` - 專案概覽命令
- `scripts/atlas/detect-project-enhanced.sh` - 專案類型檢測（規模感知）
- `scripts/atlas/scan-entropy.sh` - 高熵文件掃描腳本

**優先級調整**：
- `/atlas-overview` 列為最高優先級 (⭐⭐⭐⭐⭐)
- 與 `/atlas-pattern` 並列為最常用命令
- 使用場景：接手新專案、Code Review 準備、快速技術棧評估

**文檔更新**：
- PRD 第 3.3 節：檔案結構新增 atlas-overview.md
- PRD 第 6.1 節：核心命令新增 /atlas-overview
- PRD 第 6.2 節：新增 /atlas-overview 範例
- 場景分類表：新增「場景 0：快速理解新專案」

**設計理念**：
- `/atlas-overview` = 獨立 Stage 0（快速）
- `/atlas` = 完整三階段（深入）
- 給予用戶選擇權，不強制執行完整分析

---

### v2.5.1 (2025-11-20)

**重大決策**：
- **確定採用 Commands 而非 Skills** (決策 4)
- 架構最終定案：Commands + Helper Scripts
- 明確優先級：`/atlas-pattern` (⭐⭐⭐⭐⭐) 為最優先功能

**架構變更**：
- `.claude/skills/` → `.claude/commands/`
- 單一 Skill → 多個專門的 Commands
- 用戶明確觸發 → 更可控、更可預測

**文檔更新**：
- 第 3 章：產品架構（Commands 架構圖）
- 第 6 章：Skill 介面設計 → Command 介面設計
- 附錄 A：新增決策 4（Commands vs Skills）
- 全文統一術語：Skill → Commands

**影響**：
- 開發路徑更清晰
- 實作更簡單（單檔案 Commands）
- 符合用戶期望（明確控制）

---

### v2.5.0 (2025-11-20)

**重大變更**：
- 從獨立 CLI 工具轉為 Claude Code 整合
- 移除複雜的索引系統
- 新增輔助 Scripts 架構
- 保留 v2.0 的核心方法論

**新增**：
- 即時探索命令（find, pattern, explain）
- 5 個真實使用場景分析
- 輕量 Scripts 設計
- 優先級排序（基於真實需求）

**保留自 v2.0**：
- 三階段分析方法
- 高熵檔案優先策略
- AI 協作識別
- YAML 格式規範

---

### v2.0.0 (2025-11-19) - 研究驗證版

**重大成果**：
- ✅ 完成手動 Prompts 方法論
- ✅ 驗證 5 個真實專案（不同規模、語言、成熟度）
- ✅ YAML vs TOON 格式決策（選擇 YAML）
- ✅ 規模感知算法開發
- ✅ 發現 AI 協作識別方法（Level 0-4）

**關鍵發現**：
- 資訊理論策略有效（<5% 掃描達 70-80% 理解）
- 規模感知至關重要（TINY 到 VERY_LARGE 需要不同策略）
- TOON 僅節省 14% tokens（非預期的 30-50%）
- 必須排除 .venv/node_modules
- 基準測試揭示真相

**驗證專案**：
- trySwiftTokyoApp (iOS, MEDIUM)
- taiwan-calendar (Python, SMALL)
- Mir01 (JavaScript, LARGE)
- chiahsing1115 系列 (5 個 TINY 專案)
- 其他測試專案

---

### v1.0.0 (2025-01-15) - 原始 PRD

**原始設計**（後續已轉向）：
- 獨立 CLI 工具設計（已轉向 Commands）
- 完整索引系統架構（已改為即時分析）
- TOON 格式提出（已評估並選擇 YAML）
- Parser/Index/Storage/Query 四層架構（已移除）

---

## v1.0 關鍵學習（詳細版）

**2025-11-22 完成的 v1.0 驗證揭示了關鍵洞察**：

### 1. 資訊理論確實有效 ✅

**發現**：
- 掃描 <5% 檔案可達到 70-80% 理解（5/5 專案驗證）
- README + package.json 提供不成比例的資訊量
- 高熵優先策略節省 95%+ 時間

**證據**：
- trySwiftTokyoApp: 掃描 12/500 檔案 (2.4%) → 75% 理解
- taiwan-calendar: 掃描 8/150 檔案 (5.3%) → 80% 理解
- Mir01: 掃描 15/800 檔案 (1.9%) → 70% 理解

**影響**：
- 驗證了核心方法論
- 證明高熵檔案（configs、READMEs、models）包含不成比例的資訊
- 結構 > 實作細節的策略有效

---

### 2. 規模感知至關重要 ⭐

**問題**：
- 固定掃描數量對 TINY 專案失效（60% 掃描率）
- chiahsing1115-counter: 只有 3 個檔案，掃描 2 個 = 67% 掃描率
- 違反了 "<5% 掃描" 的核心原則

**解決方案**：規模感知文件限制和假設目標

| 專案規模 | 檔案數量 | 掃描限制 | 掃描率 | 假設目標 |
|---------|---------|---------|--------|---------|
| TINY | <5 files | 1-2 檔案 | 20-40% | 5-8 假設 |
| SMALL | 5-15 files | 2-3 檔案 | 13-20% | 7-10 假設 |
| MEDIUM | 15-50 files | 4-6 檔案 | 8-12% | 10-15 假設 |
| LARGE | 50-150 files | 6-10 檔案 | 4-7% | 12-18 假設 |
| VERY_LARGE | >150 files | 10-15 檔案 | 3-7% | 15-20 假設 |

**實作**：
- `detect-project-enhanced.sh` 實作規模檢測
- 自動調整掃描限制和假設數量
- 確保所有規模的專案都保持 <10% 掃描率

**影響**：
- 解決了 TINY 專案的過度掃描問題
- 為不同規模提供適當的分析深度
- 簡單專案不需要複雜假設，大專案需要更多假設

---

### 3. YAML > TOON（格式決策） ⭐

**測試結果**（cursor-talk-to-figma-mcp 專案）：
- TOON: 807 tokens
- YAML: 938 tokens
- **差異**: 131 tokens (14% 節省)

**為何只有 14%，而非預期的 30-50%？**

**原因分析**：
- **內容（假設、證據）佔 85%** - 這部分無法壓縮
- **結構（YAML vs TOON 語法）僅佔 15%** - 這才是能優化的部分
- 即使結構壓縮 100%，總節省也只有 15%

**決策**：標準生態系統 > 14% 邊際優化

**YAML 的優勢**：
- 標準格式，廣泛使用
- 完整工具鏈（解析器、驗證器、格式化工具）
- IDE 支援（語法高亮、自動完成、驗證）
- 生態系統整合（CI/CD、配置管理、API）

**符合"極簡"哲學**：
- 使用標準工具，不重新發明輪子
- 14% 節省不值得犧牲生態系統價值
- 開發者熟悉度 > 輕微的 token 優化

**詳細分析**：見 `.dev-notes/toon-vs-yaml-analysis.md`

---

### 4. 必須排除 .venv/node_modules

**問題**：
- Python 專案：.venv 可虛增 1000+ 檔案
- Node 專案：node_modules 同樣問題
- 導致檔案數量計算錯誤，掃描率失真

**範例**：
- taiwan-calendar 實際代碼：~150 個檔案
- 包含 .venv：~1200 個檔案
- 掃描 8 個檔案：5.3% (正確) vs 0.67% (錯誤)

**解決方案**：
- `detect-project-enhanced.sh` 實作正確的排除邏輯
- 排除目錄：.venv, node_modules, vendor, __pycache__, .git, build, dist

**影響**：
- 準確計算專案規模
- 正確的掃描率統計
- 避免掃描無意義的依賴檔案

---

### 5. 基準測試揭示真相

**測試結果**（5 個專案）：

| 指標 | 通過率 | 發現問題 |
|-----|--------|---------|
| 速度 (10-15 分鐘) | 100% | ✅ 全部通過 |
| 大小 (<20k tokens) | 100% | ✅ 全部通過 |
| 掃描率 (<10%) | 40% | ⚠️ TINY 專案失敗 |
| 假設數量 (適當) | 40% | ⚠️ TINY 專案過多 |

**關鍵發現**：
- 理論看起來很好，但真實測試才發現規模感知問題
- TINY 專案的掃描率達 60%，嚴重違反原則
- 修正後改善為 20-40%（仍高但可接受）

**教訓**：
- **在真實專案測試，不只是理論**
- 建立基準測試腳本（benchmark.sh）
- 持續追蹤指標
- 多樣化測試集（不同規模、語言、成熟度）

---

### 6. AI 協作模式可檢測

**Level 3 特徵**（系統化 AI 協作）：
- ✅ 有 CLAUDE.md 或類似的 AI 配置
- ✅ 15-20% 註解密度（相比人工的 5-8%）
- ✅ 98%+ 代碼一致性
- ✅ 100% Conventional Commits
- ✅ 文檔/代碼比 >1:1

**檢測方法**：
- 搜尋 CLAUDE.md、.cursor/rules/、.aider/
- 計算註解密度（註解行數 / 代碼行數）
- 分析 commit 訊息格式
- 比較文檔行數與代碼行數

**範例**：
- trySwiftTokyoApp: Level 1（偶爾使用 AI）
- taiwan-calendar: Level 0（無 AI）
- Mir01: Level 2（基礎 AI 使用）
- SourceAtlas 本身: Level 3（系統化 AI 協作）

**影響**：
- 可量化評估 AI 輔助開發
- 識別開發模式和成熟度
- 為未來的 AI 協作研究提供方法論

---

## 實作核心原則（基於 v1.0 經驗）

實作任何新功能時，**必須遵循**：

1. **規模感知設計** - 不要一刀切，根據專案大小調整
   - TINY 專案不需要複雜分析
   - VERY_LARGE 專案需要更多假設
   - 使用 `detect-project-enhanced.sh` 自動檢測

2. **標準優於自訂** - 用 YAML、Markdown，不發明格式
   - 除非節省 >30% 且無生態系統替代
   - 14% 節省不值得犧牲標準工具

3. **測試先行** - 在 3+ 真實專案測試，不只是理論
   - 覆蓋不同規模（TINY → VERY_LARGE）
   - 覆蓋不同語言（Python, JavaScript, Swift, etc.）
   - 覆蓋不同成熟度（原型 → 生產級）

4. **文檔同步** - 邊開發邊寫文檔，不要事後補
   - 開發過程中更新 CLAUDE.md
   - 記錄關鍵決策到 .dev-notes/
   - 保持 README、PRD、USAGE_GUIDE 同步

5. **基準測量** - 建立指標，持續追蹤
   - 使用 `benchmark.sh` 自動測試
   - 追蹤：速度、大小、tokens、掃描率、假設數量
   - 回歸測試確保改進不破壞現有功能

6. **排除目錄** - 永遠排除 .venv、node_modules、__pycache__
   - 準確計算專案規模
   - 避免掃描依賴檔案
   - 使用 `detect-project-enhanced.sh` 的排除邏輯

7. **資訊理論** - 高熵優先，結構 > 實作細節
   - README、configs、models 優先
   - 避免深入業務邏輯代碼
   - 2-3 個範例勝過閱讀所有檔案

8. **證據為本** - 每個論點需要證據（file:line 引用）
   - 假設必須有信心等級（0.0-1.0）
   - 證據必須指向具體檔案和行號
   - 可驗證勝過推測

---

**結束語**：

這份歷史記錄保存了 SourceAtlas 從概念到實作的完整演進過程。雖然這些資訊不是日常開發必需的，但它們記錄了重要的決策過程、經驗教訓和方法論驗證。

當你需要：
- 理解為什麼做某個決策
- 參考過去的測試結果
- 學習方法論演進
- 準備類似專案的規劃

可以回到這份文件查閱。

**現在，專注於快速探索和開發吧！** 🚀
